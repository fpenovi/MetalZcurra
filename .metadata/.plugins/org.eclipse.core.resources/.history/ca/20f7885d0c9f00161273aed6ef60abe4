/*
 * HandleKeyHoldServer.cpp
 *
 *  Created on: Oct 30, 2016
 *      Author: franch
 */

#include "HandleKeyHoldServer.h"
#include "../ObjectManager.h"
#include "../protocolos/ProtocoloVistaUpdate.h"

using namespace chrono;

struct argkh {
    int* keyPressed;
    bool* isKhOn;
    bool* isKhPaused;
    string* emisor;
    unordered_map<string, list<Mensaje*>*>* conectadosHash;
    unordered_map<string, pthread_mutex_t>* mutexesHash;
};

void* handleKeyHoldFunc(void* argKh) {

    bool* isKhOn = ( (argkh_t*) argKh )->isKhOn;
    bool* isKhPaused = ( (argkh_t*) argKh)->isKhPaused;
    int* keyPressed = ( (argkh_t*) argKh)->keyPressed;
    ObjectManager* objectManager = ObjectManager::getInstance();
    string* emisor = ( (argkh_t*) argKh)->emisor;
    unordered_map<string, list<Mensaje*>*>* conectadosHash = ( (argkh_t*) argKh)->conectadosHash;
    unordered_map<string, pthread_mutex_t>* mutexesHash = ( (argkh_t*) argKh)->mutexesHash;

    time_point<high_resolution_clock> start;
    start = high_resolution_clock::now();
    microseconds intervalo(30000);	// 30ms

    while (*isKhOn) {
        time_point<high_resolution_clock> actual;
        actual = high_resolution_clock::now();

        auto deltaTiempo = actual.time_since_epoch() - start.time_since_epoch();
        auto elapsed_ms = duration_cast<microseconds>(deltaTiempo);

        if (elapsed_ms.count() >= intervalo.count()) {

            if (*isKhOn && !(*isKhPaused)) {

                int idEmisor = objectManager->getIdByUsername(*emisor);
                Personaje* personaje = objectManager->getObject(idEmisor);
                bool avanzar = objectManager->puedoAvanzar();
                int* posX = objectManager->getPosX();

                ProtocoloVistaUpdate update;
                int aux;

                switch( *keyPressed ) {

                    case SDLK_LEFT:
                        personaje->setVelx(-personaje->getPersonaje_VEL());
                        personaje->moverX(avanzar, posX);

                        update.setEstado(personaje->getSeMovio());
                        update.setX(*posX);
                        update.setY(personaje->getPosy());
                        update.setObject_id(idEmisor);
                        update.setPosCamara(personaje->getPosCamara());
                        update.setConectado(personaje->getConectado());
                        update.setSpriteIndex(personaje->getFrameCorriendo());
                        break;

                    case SDLK_RIGHT:
                        aux = *posX;
                        personaje->setVelx(personaje->getPersonaje_VEL());
                        personaje->moverX(avanzar, posX);

                        if (aux < *posX){
                            objectManager->moverCamara(idEmisor);
                            objectManager->moverDesconectados();
                        }

                        update.setEstado(personaje->getSeMovio());
                        update.setX(*posX);
                        update.setY(personaje->getPosy());
                        update.setObject_id(idEmisor);
                        update.setPosCamara(personaje->getPosCamara());
                        update.setConectado(personaje->getConectado());
                        update.setSpriteIndex(personaje->getFrameCorriendo());
                        break;

                }

                int result;
                string mensaje = update.toString();

                for (auto kv : *conectadosHash) {

                    Mensaje* mensajeNuevo = new Mensaje(*emisor, kv.first, mensaje);

                    result = pthread_mutex_lock(&((*mutexesHash)[kv.first]));
                    if (result != 0) perror("Fallo el pthread_mutex_lock en agregar msjs (a todos)");

                    kv.second->push_back(mensajeNuevo);

                    result = pthread_mutex_unlock(&((*mutexesHash)[kv.first]));
                    if (result != 0) perror("Fallo el pthread_mutex_lock en agregar msjs (a todos)");
                }
            }

            start = chrono::system_clock::now();
        }
    }

    return NULL;
}

HandleKeyHoldServer::HandleKeyHoldServer() {
	// TODO Auto-generated constructor stub

}

HandleKeyHoldServer::~HandleKeyHoldServer() {
	// TODO Auto-generated destructor stub
}

